----------------------
Hashed Based Indexing:
----------------------

- everything is on disk

*************************************************
\/\/

insertion in hash index:
------------------------

- if there is space, place in the right block
  otherwise, create overflow block

time-complexity = best-case: O(1), worst: O(n),
                  where n is the number of records
                  in an overflow-block.
                                             /\/\
*************************************************

To solve the problem of having too many 
overflow-blocks, use an extensible hash index.

*************************************************
\/\/

extensible hash index:
----------------------
- allows hash index to grow, avoiding performance
  degradation.

assume a hash function h returns numbers in:
    { 0, ..., 2^(k) - 1 }

start with n = 2^i < 2^k, only look at first i
                           most significant bits


Example., i = 1, n = 2, k = 4

----------------------
| 0 | ----> | 0(010) |
-----       ----------
            | 
            ----------

----------------------
| 1 | ----> | 1(011) |
-----       ----------
            | 
            ----------
#1

      insert 1110:
      - apply h(1110)

----------------------
| 0 | ----> | 0(010) |
-----       ----------
            | 
            ----------

----------------------
| 1 | ----> | 1(011) |
-----       ----------
            | 1(110) | 
            ----------

#2
       insert 1010
       - apply h(1010)

----------------------
| 0 | ----> | 0(010) |
-----       ----------
            | 
            ----------

------------------------------
| 1 | ----> | 1(011)         |
-----       ------------------
            | 1(110), 1(010) | 
            ------------------

    to insert 1010, split the block and extend
    the bucket array.

    set i = 2

-----------------------
| 00 | ----> | 0(010) |
------       ----------
| 01 |       |        | 
------       ---------- 

-------------------------------
| 10 | ----> | 10(11)         |
------       ------------------
             | 10(10)         | 
             ------------------

-------------------------------
| 11 | ----> | 11(10)         |
------       ------------------
             |                | 
             ------------------

#3
         insert 0000 and 0101

         i = 2

-------------------------------
| 00 | ----> | 0(010)         |
------       ------------------
| 01 |       | 0(000), 0(101) | <- ERROR!
------       ------------------

-------------------------------
| 10 | ----> | 10(11)         |
------       ------------------
             | 10(10)         | 
             ------------------

-------------------------------
| 11 | ----> | 11(10)         |
------       ------------------
             |                | 
             ------------------

      to fix the error, split the block
      and re-use the bucket array.

-------------------------------
| 00 | ----> | 0(010)         |
------       ------------------
             | 0(000)         |
             ------------------

-------------------------------
| 01 | ----> | 0(101)         |
------       ------------------
             |                |
             ------------------

-------------------------------
| 10 | ----> | 10(11)         |
------       ------------------
             | 10(10)         | 
             ------------------

-------------------------------
| 11 | ----> | 11(10)         |
------       ------------------
             |                | 
             ------------------


the performance of a extensible hash index
is always O(1) for insertion.

disadvantage of extensible hash index:
- a block split could take awhile
- space could go unused with expansions

                                             /\/\
*************************************************


Extensible hash indexes are not used bc they are
wasteful of memory.

To solve this, Linear hash indexes are used.


*************************************************
\/\/

Linear Hash Index:
------------------
- add only one block at a time
- n is no longer a power of 2
- let i be the # of bits required to address 
  n blocks
  = 2^(i-1) < n <= 2^i
- after computing h(k), use last i bits:
  * if last i bits represent a number >= n, 
    flip msb of i to get a number < n
- allow overflow blocks

Example:

#1

      assume n = 3  (the number of entries in
                     directory in main memory)
             i = 2
  
     insert 0111:

     to search/insert a hash value of 0111:

       search directory for 11:

         if found, check if there is space
           if there is space, insert 0111
           else create an overflow block

         if not found, flip msb of hash value
         and search for that value in the 
         directory.

           if found, check if there is space
             if there is space, insert 0111
             else create an overflow block


-------------------------------
| 00 | ----> | (01)00         |
------       ------------------
             | (11)00         |
             ------------------

-------------------------------
| 01 | ----> | (01)11 BIT FLIP|
------       ------------------
             |                |
             ------------------

-------------------------------
| 10 | ----> | (10)10         |
------       ------------------
             |                | 
             ------------------

#2

     insert 1000,
                i = 2

     solution = create an overflow block

-------------------------------------
| 00 | ----> | (01)00 | -> | (10)00 |
------       ----------    ----------
             | (11)00 |    |        |
             ----------    ----------

-----------------------
| 01 | ----> | (01)11 |
------       ----------
             |        |
             ----------

-----------------------
| 10 | ----> | (10)10 |
------       ----------
             |        | 
             ----------

     growing the number of blocks, n, when 
     the average number of records per block
     exceeds X percentage

     n = n + 1


#3

    from n = 3 to n = 4

    n = 3
    i = 2
-----------------------
| 00 | ----> | (01)00 |
------       ----------
             | (11)00 |
             ----------

-----------------------
| 01 | ----> | (01)11 |
------       ----------
             |        |
             ----------

-----------------------
| 10 | ----> | (10)10 |
------       ----------
             |        | 
             ----------


    n = 4
    i = 2
-----------------------
| 00 | ----> | (01)00 |
------       ----------
             | (11)00 |
             ----------

-----------------------
| 01 | ----> | (00)01 |
------       ----------
             |        |
             ----------

-----------------------
| 10 | ----> | (10)10 |
------       ----------
             |        | 
             ----------

-----------------------
| 11 | ----> | (01)11 |
------       ----------
             |        | 
             ----------


#4 
   extension from n = 4 to n = 5
   new bit: i = 3
   ** requires a reordering of values

------------------------
| 000 | ----> |        |
-------       ----------
              |        |
              ----------

------------------------
| 001 | ----> | (0)001 |
-------       ----------
              |        |
              ----------

------------------------
| 010 | ----> | (1)010 |
-------       ----------
              |        |
              ----------

---------------------------------
| 011 | ----> | (0)111 BIT FLIP |
-------       -------------------
              |        | 
              ----------

------------------------
| 100 | ----> | (0)100 |
-------       ----------
              | (1)100 |
              ----------
                                             /\/\
*************************************************


*************************************************
\/\/

                                             /\/\
*************************************************


*************************************************
\/\/

                                             /\/\
*************************************************


*************************************************
\/\/

                                             /\/\
*************************************************


*************************************************
\/\/

                                             /\/\
*************************************************


*************************************************
\/\/

                                             /\/\
*************************************************


